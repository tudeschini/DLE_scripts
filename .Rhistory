library(shape)
library(graphics)
library(Surrogate)
library(fields)
library(WDI)
library(qdap)
library(plotrix)
library(data.table)
library(microbenchmark)
library(ineq)
library(gdxrrw)
library(gridExtra)
library("ggrepel")
library(colorRamps)
library(devtools)  # This library needed to do multiple returns from functions
source_url("https://raw.githubusercontent.com/ggrothendieck/gsubfn/master/R/list.R")
# Run RAS and construct final matrix in original dimension
library(mipfp)
#setwd("H:/MyDocuments/IO work/DLE_scripts")
setwd("C:/Users/tudeschi/SharePoint/DLE - Documents/WS2 - Documents/Analysis/IO/")
xlcFreeMemory()
source("Generic function to access database.R") # Better run the Script directly
.First <- function(){
.ls.objects <- function (pos = 1, pattern, order.by,
decreasing=FALSE, head=FALSE, n=5) {
napply <- function(names, fn) sapply(names, function(x)
fn(get(x, pos = pos)))
names <- ls(pos = pos, pattern = pattern)
obj.class <- napply(names, function(x) as.character(class(x))[1])
obj.mode <- napply(names, mode)
obj.type <- ifelse(is.na(obj.class), obj.mode, obj.class)
obj.prettysize <- napply(names, function(x) {
capture.output(format(utils::object.size(x), units = "auto")) })
obj.size <- napply(names, object.size)
obj.dim <- t(napply(names, function(x)
as.numeric(dim(x))[1:2]))
vec <- is.na(obj.dim)[, 1] & (obj.type != "function")
obj.dim[vec, 1] <- napply(names, length)[vec]
out <- data.frame(obj.type, obj.size, obj.dim)
names(out) <- c("Type", "Size", "Rows", "Columns")
if (!missing(order.by))
out <- out[order(out[[order.by]], decreasing=decreasing), ]
if (head)
out <- head(out, n)
out
}
# shorthand
lsos <- function(..., n=10) {
.ls.objects(..., order.by="Size", decreasing=TRUE, head=TRUE, n=n)
}
view <- function(data, autofilter=TRUE) {
# data: data frame
# autofilter: whether to apply a filter to make sorting and filtering easier
open_command <- switch(Sys.info()[['sysname']],
Windows= 'open',
Linux  = 'xdg-open',
Darwin = 'open')
require(XLConnect)
temp_file <- paste0(tempfile(), '.xlsx')
wb <- XLConnect::loadWorkbook(temp_file, create = TRUE)
XLConnect::createSheet(wb, name = "temp")
XLConnect::writeWorksheet(wb, data, sheet = "temp", startRow = 1, startCol = 1)
if (autofilter) setAutoFilter(wb, 'temp', aref('A1', dim(data)))
XLConnect::saveWorkbook(wb, )
system(paste(open_command, temp_file))
}
}
??Ipfp
install.packages("mipfp")
install.packages("mipfp")
list[result_BRA_noVal, NC_BRA_noVal] <- Run_rIPFP(bridge_ICP_EXIO_q[,-1], "BRA")
??countrycode
library(countrycode)
list[result_BRA_noVal, NC_BRA_noVal] <- Run_rIPFP(bridge_ICP_EXIO_q[,-1], "BRA")
# Things you might want to change
# options(papersize="a4")
# options(editor="notepad")
# options(pager="internal")
# set the default help type
# options(help_type="text")
options(help_type="html")
# set a site library
# .Library.site <- file.path(chartr("\\", "/", R.home()), "site-library")
# set a CRAN mirror
# local({r <- getOption("repos")
#       r["CRAN"] <- "http://my.local.cran"
#       options(repos=r)})
# Give a fortune cookie, but only to interactive sessions
# (This would need the fortunes package to be installed.)
#  if (interactive())
#    fortunes::fortune()
options(java.parameters = "-Xmx16g")
library(RJDBC)
library(data.table)
library(tidyr)
library(openxlsx)
library(XLConnect)
library(readxl)
library(Surrogate)
library(ggplot2)
library(stringr)
library(plyr)
library(dplyr)
library(pastecs)
library(countrycode)
library(scatterplot3d)
library(rgl)
library(car)
library(shape)
library(graphics)
library(Surrogate)
library(fields)
library(WDI)
library(qdap)
library(plotrix)
library(data.table)
library(microbenchmark)
library(ineq)
library(gdxrrw)
library(gridExtra)
library("ggrepel")
library(colorRamps)
library(devtools)  # This library needed to do multiple returns from functions
source_url("https://raw.githubusercontent.com/ggrothendieck/gsubfn/master/R/list.R")
# Run RAS and construct final matrix in original dimension
library(mipfp)
#setwd("H:/MyDocuments/IO work/DLE_scripts")
setwd("C:/Users/tudeschi/SharePoint/DLE - Documents/WS2 - Documents/Analysis/IO/")
xlcFreeMemory()
source("Generic function to access database.R") # Better run the Script directly
.First <- function(){
.ls.objects <- function (pos = 1, pattern, order.by,
decreasing=FALSE, head=FALSE, n=5) {
napply <- function(names, fn) sapply(names, function(x)
fn(get(x, pos = pos)))
names <- ls(pos = pos, pattern = pattern)
obj.class <- napply(names, function(x) as.character(class(x))[1])
obj.mode <- napply(names, mode)
obj.type <- ifelse(is.na(obj.class), obj.mode, obj.class)
obj.prettysize <- napply(names, function(x) {
capture.output(format(utils::object.size(x), units = "auto")) })
obj.size <- napply(names, object.size)
obj.dim <- t(napply(names, function(x)
as.numeric(dim(x))[1:2]))
vec <- is.na(obj.dim)[, 1] & (obj.type != "function")
obj.dim[vec, 1] <- napply(names, length)[vec]
out <- data.frame(obj.type, obj.size, obj.dim)
names(out) <- c("Type", "Size", "Rows", "Columns")
if (!missing(order.by))
out <- out[order(out[[order.by]], decreasing=decreasing), ]
if (head)
out <- head(out, n)
out
}
# shorthand
lsos <- function(..., n=10) {
.ls.objects(..., order.by="Size", decreasing=TRUE, head=TRUE, n=n)
}
view <- function(data, autofilter=TRUE) {
# data: data frame
# autofilter: whether to apply a filter to make sorting and filtering easier
open_command <- switch(Sys.info()[['sysname']],
Windows= 'open',
Linux  = 'xdg-open',
Darwin = 'open')
require(XLConnect)
temp_file <- paste0(tempfile(), '.xlsx')
wb <- XLConnect::loadWorkbook(temp_file, create = TRUE)
XLConnect::createSheet(wb, name = "temp")
XLConnect::writeWorksheet(wb, data, sheet = "temp", startRow = 1, startCol = 1)
if (autofilter) setAutoFilter(wb, 'temp', aref('A1', dim(data)))
XLConnect::saveWorkbook(wb, )
system(paste(open_command, temp_file))
}
}
list[result_BRA_noVal, NC_BRA_noVal] <- Run_rIPFP(bridge_ICP_EXIO_q[,-1], "BRA")
n_draw <- 100
D_val_uncertainty <- 0
list[result_BRA_noVal, NC_BRA_noVal] <- Run_rIPFP(bridge_ICP_EXIO_q[,-1], "BRA")
n_draw <- 10
D_val_uncertainty <- 0
list[result_BRA_noVal, NC_BRA_noVal] <- Run_rIPFP(bridge_ICP_EXIO_q[,-1], "BRA")
func1 <- function (x) {
a <- diag(1/rowSums(x))
a[is.infinite(a)] <- 0
x <- a %*% x
}
final_alloc_list_BRA_noVal <- lapply(result_BRA_noVal, func1)
xlcFreeMemory()
alloc_nonRAS <- get_bridge_COICOP_EXIO(bridge_ICP_EXIO_q[,-1], n_draw)
D_val_uncertainty <- 0
BRA_inten_RAS_noVal <- SetupSectorIntensities(final_alloc_list_BRA_noVal, NC_BRA_noVal, "BR")
BRA_inten_nonRAS_noVal <- SetupSectorIntensities(alloc_nonRAS, NC_BRA_noVal, "BR")
head(final_alloc_list_BRA_noVal)
View(final_alloc_list_BRA_noVal)
str(final_alloc_list_BRA_noVal)
xlcFreeMemory()
D_val_uncertainty <- 0
BRA_inten_RAS_noVal <- SetupSectorIntensities(final_alloc_list_BRA_noVal, NC_BRA_noVal, "BR")
BRA_inten_nonRAS_noVal <- SetupSectorIntensities(alloc_nonRAS, NC_BRA_noVal, "BR")
BRA_inten_RAS_noVal <- SetupEmissionIntensities(final_alloc_list_BRA_noVal, NC_BRA_noVal, "BR")
BRA_inten_nonRAS_noVal <- SetupEmissionIntensities(alloc_nonRAS, NC_BRA_noVal, "BR")
BRA_inten_RAS_noVal <- SetupSectorIntensities(final_alloc_list_BRA_noVal, NC_BRA_noVal, "BR")
BRA_inten_nonRAS_noVal <- SetupSectorIntensities(alloc_nonRAS, NC_BRA_noVal, "BR")
BRA_emiss_inten_RAS_noVal <- SetupEmissionIntensities(final_alloc_list_BRA_noVal, NC_BRA_noVal, "BR")
BRA_emiss_inten_nonRAS_noVal <- SetupEmissionIntensities(alloc_nonRAS, NC_BRA_noVal, "BR")
View(BRA_inten_RAS_noVal)
str(BRA_inten_RAS_noVal)
str(BRA_emiss_inten_RAS_noVal)
View(BRA_emiss_inten_RAS_noVal)
no_expense_BRA <- which((rowSums(bridge_ICP_EXIO_q[,-1])!=0) & (BRA_FD_ICP_usd2007[,1]==0))
no_expense_BRA <- no_expense_BRA[!(no_expense_BRA %in% grep("UNBR", ICP_catnames))]   # Remove UNBR items >>>> Comunicate Jihoon <<<< no_expense_IND
BRA_inten_RAS_combined_noVal <- BRA_inten_RAS_noVal
BRA_inten_RAS_combined_noVal[,no_expense_BRA] <- BRA_inten_nonRAS_noVal[,no_expense_BRA]
BRA_emiss_inten_RAS_combined_noVal <- BRA_emiss_inten_RAS_noVal
BRA_inten_RAS_combined_noVal[,no_expense_BRA] <- BRA_inten_nonRAS_noVal[,no_expense_BRA] # primary energy
BRA_emiss_inten_RAS_combined_noVal[,no_expense_BRA] <- BRA_emiss_inten_RAS_combined_noVal[,no_expense_BRA] # emissions >>> CO2? non-CO2?
saveRDS(BRA_emiss_inten_RAS_combined_noVal, "C:/Users/tudeschi/Documents/DLE_scripts/Outputs/Saved tables/BRA_emiss_inten_RAS_combined_noVal.RDS")
saveRDS(BRA_emiss_inten_RAS_combined_noVal, "C:/Users/tudeschi/OneDrive - IIASA/Projects/ECOPA/ECOPA Final Task 3/Data/BRA_emiss_inten_RAS_combined_noVal.RDS")
View(BRA_HH)
path_em <- "C:/Users/tudeschi/SharePoint/DLE - Documents/IO/Data - EXIOBASE/extension2.3.0/"
emissions <- read.table(paste(path_em, "mrEmissions_pxp_version2.3.0", sep=""), header=FALSE, sep="\t", dec=".",
skip=2, nrows=85, stringsAsFactors = FALSE)
path_em <- "C:/Users/tudeschi/SharePoint/DLE - Documents/IO/Data - EXIOBASE/extension2.3.0/"
emissions <- read.table(paste(path_em, "mrEmissions_pxp_version2.3.0", sep=""), header=FALSE, sep="\t", dec=".",
skip=2, nrows=85, stringsAsFactors = FALSE)
emissions <- read.table(paste(path_em, "mrEmissions_pxp_version2.3.0.txt", sep=""), header=FALSE, sep="\t", dec=".",
skip=2, nrows=85, stringsAsFactors = FALSE)
View(emissions)
emissions <- emissions %>% select(-V2, -V3) %>% filter(grepl('CH4|CO2|N2O|HFC|PFC', V1))
View(emissions)
emissions <- read.table(paste(path_em, "mrEmissions_pxp_version2.3.0.txt", sep=""), header=FALSE, sep="\t", dec=".",
skip=2, nrows=85, stringsAsFactors = FALSE)
summary(emissions$V1)
descr::freq(emissions$V1)
emissions <- emissions %>% select(-V2, -V3) %>% filter(grepl('CH4|CO2|N2O|HFC|PFC', V1))
GHG_item <- emissions$V1
emissions <- read.table(paste(path_em, "mrEmissions_pxp_version2.3.0.txt", sep=""), header=FALSE, sep="\t", dec=".",
skip=2, nrows=110, stringsAsFactors = FALSE)
emissions <- emissions %>% select(-V2, -V3) %>% filter(grepl('CH4|CO2|N2O|HFC|PFC', V1))  # Emissions table in kg, except for HFC and PFC in Kg CO2 eq.
View(emissions)
emissions <- read.table(paste(path_em, "mrEmissions_pxp_version2.3.0.txt", sep=""), header=FALSE, sep="\t", dec=".",
skip=2, nrows=110, stringsAsFactors = FALSE)
emissions <- emissions %>% select(-V2, -V3) %>% filter(grepl('CH4|CO2|N2O|HFC|PFC', V1))  # Emissions table in kg, except for HFC and PFC in Kg CO2 eq.
View(emissions)
emissions <- read.table(paste(path_iot, "mrEmissions_version2.2.2.txt", sep=""), header=FALSE, sep="\t", dec=".",
skip=2, nrows=85, stringsAsFactors = FALSE)
path_em <- "C:/Users/tudeschi/SharePoint/DLE - Documents/IO/Data - EXIOBASE/extension2.3.0/"
emissions <- read.table(paste(path_em, "mrEmissions_pxp_version2.3.0.txt", sep=""), header=FALSE, sep="\t", dec=".",
skip=2, nrows=110, stringsAsFactors = FALSE)
emissions <- emissions %>% select(-V2, -V3) %>% filter(grepl('CH4|CO2|N2O|HFC|PFC', V1))  # Emissions table in kg, except for HFC and PFC in Kg CO2 eq.
GHG_item <- emissions$V1
View(emissions)
emission_factor = read.csv("C:/Users/tudeschi/OneDrive - IIASA/Data/Emissions/WG1/Emission metrics_WG1_AR5.csv")
?add_row
emissions$V1
write.csv(emissions$V1, C:/Users/tudeschi/OneDrive - IIASA/Data/Emissions/WG1/Emissions_names.csv )
write.csv(emissions$V1, "C:/Users/tudeschi/OneDrive - IIASA/Data/Emissions/WG1/Emissions_names.csv" )
emission_factor = read.csv("C:/Users/tudeschi/Documents/DLE_scripts/Input/Data/Emission metrics_WG1_AR5.csv") # Convertion factors WG1 AR5
emission_factor = read.csv("C:/Users/tudeschi/Documents/DLE_scripts/Input/Data/Emission metrics_WG1_AR5_EXIOBASE2.3.0.csv") # Convertion factors WG1 AR5
emissions <- emissions %>% select(-V2, -V3) %>% filter(grepl('CH4|CO2|N2O|HFC|PFC', V1)) %>% rename(GHG_item = V1)  # Emissions table in kg, except for HFC and PFC in Kg CO2 eq.
emissions <- read.table(paste(path_em, "mrEmissions_pxp_version2.3.0.txt", sep=""), header=FALSE, sep="\t", dec=".",
skip=2, nrows=110, stringsAsFactors = FALSE)
emissions <- emissions %>% select(-V2, -V3) %>% filter(grepl('CH4|CO2|N2O|HFC|PFC', V1)) %>% rename(GHG_item = V1)  # Emissions table in kg, except for HFC and PFC in Kg CO2 eq.
View(emissions)
GHG_item <- emissions$GHG_item
emission_conv = read.csv("C:/Users/tudeschi/Documents/DLE_scripts/Input/Data/Emission metrics_WG1_AR5_EXIOBASE2.3.0.csv") # Convertion factors WG1 AR5
test = full_join(emissions, emission_conv)
head(test[C(9600:9602)])
head(test)
test = full_join(emissions, emission_conv) %>%
mutate_each_(funs(. * GWP100_cc), vars(c(1:9601)))  # Multipling all columns by emission conversion factor
View(test)
class(test$GWP100_cc)
test = full_join(emissions, emission_conv) %>%
test = test %>%
mutate_each_(funs(. *as.numeric(GWP100_cc)), vars(c(1:9601)))  # Multipling all columns by emission conversion factor
test$GWP100_cc <- as.numeric(test$GWP100_cc)
class(test$GWP100_cc)
test = test %>%
mutate_each_(funs(. * GWP100_cc), vars(c(1:9601)))  # Multipling all columns by emission conversion factor
test$GWP100_cc[1] + 5
test$GWP100_cc[1]
test$GWP100_cc[5]
test = full_join(emissions, emission_conv) %>%
test = test %>%
mutate_each_(funs(. * GWP100_cc), vars(c(1:9601)))  # Multipling all columns by emission conversion factor
test[9601]
test[9602]
test[1]
test[2]
test = full_join(emissions, emission_conv) %>%
test = test %>%
mutate_each_(funs(. * GWP100_cc), vars(c(2:9601)))  # Multipling all columns by emission conversion factor
test = test %>%
mutate_each_(funs(. * GWP100_cc), vars(c(2:9601)))  # Multipling all columns by emission conversion factor
View(test)
57094.024*34
test2 = full_join(emissions, emission_conv) %>%
mutate_each_(funs(. * GWP100_cc), vars(c(2:9601)))  # Multipling all columns by emission conversion factor
View(test2)
emissions = full_join(emissions, emission_conv) %>%
mutate_each_(funs(. * GWP100_cc), vars(c(2:9601)))  # Multipling all columns by emission conversion factor
emissions <- emissions %>% select(-V1)
names(emissions)
emissions <- emissions %>% select(-GHG_item)
indirect_em_int <- as.matrix(emissions) %*% as.matrix(L_inverse)   # (intensity by sector) * (I-A)^-1
path_iot <- "C:/Users/tudeschi/SharePoint/DLE - Documents/IO/Data - EXIOBASE/mrIOT_PxP_ita_coefficient_version2.2.2/"
path_sut <- "C:/Users/tudeschi/SharePoint/DLE - Documents/IO/Data - EXIOBASE/mrSUT_version2.2.2/"
final_demand <- read.table(paste(path_iot, "mrFinalDemand_version2.2.2.txt", sep=""), header=FALSE, sep="\t", dec=".", skip=2)
final_demand <- final_demand[,c(-1,-2,-3)]
L_inverse <- read.table(paste(path_iot, "L_inverse.txt", sep=""), header=FALSE, sep=",", dec=".")
factor_input <- read.table(paste(path_iot, "mrFactorInputs_version2.2.2.txt", sep=""), header=FALSE, sep="\t", dec=".", skip=2)
factor_input <- factor_input[,c(-1,-2)]
supplym <- read.table(paste(path_sut, "mrSupply_version2.2.2.txt", sep=""), header=FALSE, sep="\t", dec=".")
fd_materials <- read.table(paste(path_iot, "mrFDMaterials_version2.2.0.txt", sep=""), header=FALSE, sep="\t", dec=".", skip=2)
fd_materials <- fd_materials[,c(-1,-2)]
materials <- read.table(paste(path_iot, "mrMaterials_version2.2.0.txt", sep=""), header=FALSE, sep="\t", dec=".", skip=2)
materials <- materials[,c(-1,-2)]
path_em <- "C:/Users/tudeschi/SharePoint/DLE - Documents/IO/Data - EXIOBASE/extension2.3.0/"
emissions <- read.table(paste(path_em, "mrEmissions_pxp_version2.3.0.txt", sep=""), header=FALSE, sep="\t", dec=".",
skip=2, nrows=110, stringsAsFactors = FALSE)
emissions <- emissions %>% select(-V2, -V3) %>% filter(grepl('CH4|CO2|N2O|HFC|PFC', V1)) %>% rename(GHG_item = V1)  # Emissions table in kg, except for HFC and PFC in Kg CO2 eq.
GHG_item <- emissions$GHG_item
emission_conv = read.csv("C:/Users/tudeschi/Documents/DLE_scripts/Input/Data/Emission metrics_WG1_AR5_EXIOBASE2.3.0.csv") # Convertion factors WG1 AR5
emissions = full_join(emissions, emission_conv) %>%
mutate_each_(funs(. * GWP100_cc), vars(c(2:9601)))  # Multipling all columns by emission conversion factor >>> Now all rows of "emissions" are in kg CO2 eq
emissions <- emissions %>% select(-GHG_item)
View(emissions)
emissions[9601]
emissions = full_join(emissions, emission_conv) %>%
mutate_each_(funs(. * GWP100_cc), vars(c(2:9601)))  # Multipling all columns by emission conversion factor >>> Now all rows of "emissions" are in kg CO2 eq
emissions <- emissions %>% select(-GHG_item, -GWP100_cc)
View(emissions)
emissions <- read.table(paste(path_em, "mrEmissions_pxp_version2.3.0.txt", sep=""), header=FALSE, sep="\t", dec=".",
skip=2, nrows=110, stringsAsFactors = FALSE)
emissions <- emissions %>% select(-V2, -V3) %>% filter(grepl('CH4|CO2|N2O|HFC|PFC', V1)) %>% rename(GHG_item = V1)  # Emissions table in kg, except for HFC and PFC in Kg CO2 eq.
GHG_item <- emissions$GHG_item
## Convert all GHG_items to kg CO2 eq
emission_conv = read.csv("C:/Users/tudeschi/Documents/DLE_scripts/Input/Data/Emission metrics_WG1_AR5_EXIOBASE2.3.0.csv") # Convertion factors WG1 AR5
emissions = full_join(emissions, emission_conv) %>%
mutate_each_(funs(. * GWP100_cc), vars(c(2:9601)))  # Multipling all columns by emission conversion factor >>> Now all rows of "emissions" are in kg CO2 eq
emissions <- emissions %>% select(-GHG_item, -GWP100_cc)
tot_use <- read.table(paste(path_sut, "mrUse_version2.2.2.txt", sep=""), header=FALSE, sep="\t", dec=".", skip=2)
tot_use <- tot_use[,c(-1,-2,-3)]
tot_demand <- rowSums(final_demand) + rowSums(tot_use)
TJ_per_MTOE <- 41870
TWh_per_MTOE <- 11.63
nature_input_idx <- 1:19   # number of rows for E-carrier use after removing the row headers
emission_energy_carrier_idx <- 20:70   # number of rows for E-carrier use after removing the row headers
energy_carrier_supply_idx <- 71:139   # number of rows for E-carrier use after removing the row headers
energy_carrier_use_idx <- 140:208   # number of rows for E-carrier use after removing the row headers
energy_pri_carrier_use_idx <- c(140:154, 187:188, 191:194)   # number of rows for E-carrier use after removing the row headers
energy_sec_carrier_use_idx <- energy_carrier_use_idx[!(energy_carrier_use_idx %in% energy_pri_carrier_use_idx)]
energy_use <- materials[nature_input_idx,]  # The energy extension has not intensities but total consumptions.
y <- 1/tot_demand
y[is.infinite(y)] <- 0
energy_int <- as.matrix(energy_use) %*% diag(y)   # Derive energy intensities by dividing by total demand per sector TJ/M.EUR = MJ/EUR
indirect_E_int <- energy_int %*% as.matrix(L_inverse)   # (intensity by sector) * (I-A)^-1
str(indirect_E_int)
str(energy_use)
emission_int <- as.matrix(emissions) %*% diag(y) # The emissions extension has not intensities but total consumptions >>>> divide by total demand
energy_use <- materials[nature_input_idx,]  # The energy extension has not intensities but total consumptions.
y <- 1/tot_demand
y[is.infinite(y)] <- 0
energy_int <- as.matrix(energy_use) %*% diag(y)   # Derive energy intensities by dividing by total demand per sector TJ/M.EUR = MJ/EUR
indirect_E_int <- energy_int %*% as.matrix(L_inverse)   # (intensity by sector) * (I-A)^-1
indirect_EM_int <- emission_int %*% as.matrix(L_inverse)   # (intensity by sector) * (I-A)^-1
indirect_GHG_int <- emission_int %*% as.matrix(L_inverse)   # (intensity by sector) * (I-A)^-1
rm(indirect_EM_int)
View(indirect_GHG_int)
summary(indirect_GHG_int$V2)
save(indirect_GHG_int, file="C:/Users/tudeschi/Documents/DLE_scripts/Outputs/Saved tables/indirect_GHG_int.Rda")
SetupSectorIntensities <- function (mapping_list, not_conv_idx , country = "IN") {
ind_intensity <- vector()
n_sector <- ifelse(country=="FR", n_sector_coicop, n_sector_icp_fuel)
null_demand_int <- matrix(0, 9600, n_sector)
SectoralE_per_hh <- vector()
cty_place <- which(exio_ctys==country)
cty_idx <- seq(200*(cty_place-1)+1, 200*cty_place)  # 200 EXIO commodities per country
cty_idx_fd <- seq(7*(cty_place-1)+1, 7*cty_place)   # 7 final demand columns per country
cty_fd <- matrix(final_demand[, cty_idx_fd[1]], nrow=200)  # The country's hh fd column to a matrix (200x48) in bp
a <- diag(1/rowSums(cty_fd))
a[is.infinite(a)] <- 0
cty_fd_ratio <- a %*% cty_fd  # fd exio-sectoral ratio in bp across countries
cty_fd_ratio <- matrix(cty_fd_ratio, ncol=1) # 9600x1
for (i in 1:length(mapping_list)) {  # length(mapping_list) instead of n_draws, because of potential no-convergence runs
draw_count <<- i  # Used in get_basic_price
# Identity mtx representing 1 2007USD spending in each ICP sector, now mapped to 200 EXIO sectors
unit_exio <- diag(n_sector) %*% mapping_list[[i]]  # 164x200
# To run without valuation, toggle comment on this line.
# fd_bp <- get_basic_price(t(unit_exio), country)  # Convert to bp (200x164) - each col represents bp fd in each exio sector (for 1 USD in ICP sector)
fd_bp <- t(unit_exio)
a <- do.call(rbind, replicate(48, fd_bp, simplify = FALSE))   # 48 regions in EXIO
fd_bp <- apply(a, 2, function(x) {x * cty_fd_ratio})  # 9600X164
# fd_exio <- mapping_list[[i]] %*% diag(fd_decile[,2])  # For Ensemble
# cty_fd <- null_demand_int
# cty_fd[cty_idx,] <- get_basic_price(fd_exio, country)
GHG_int <- indirect_GHG_int %*% fd_bp * EXR_EUR$r  # indirect energy use from the supply chains (MJ/USD2007)
# energy_tot <- indirect_E_int %*% cty_fd
ind_intensity <- rbind(ind_intensity, colSums(GHG_int)) # Total indirect energy/cap by decile
# print(colSums(energy_int)[75])
}
# not_conv_idx has 1 where the RAS did not converge.
ind_intensity <- ind_intensity[not_conv_idx!=1,]
return(ind_intensity)
}
GetSpecificEXIOSectorGHGIntensity <- function(cty, exio_sect) {
cty_place <- which(exio_ctys==cty)
# cty_idx_fd <- seq(7*(cty_place-1)+1, 7*cty_place)   # 7 final demand columns per country
cty_idx_ex <- seq(200*(cty_place-1)+1, 200*cty_place)   # 7 final demand columns per country
ex_idx <- which(EX_catnames==exio_sect)
int <- colSums(indirect_GHG_int[,cty_idx_ex])[ex_idx] * EXR_EUR$r   # MJ/EUR to MJ/USD2007
return(int)
}
IndirecIntensitiesByICPSect_GHG <- function(sect_idx, cty) {
# sect_idx <- grep(ICP_sect_name, ICP_catnames, ignore.case = TRUE)
print(ICP_catnames[sect_idx])
map_idx <- which(bridge_ICP_EXIO_q[sect_idx,-1]==1)
cty_alloc <- eval(parse(text=paste0(countrycode(cty,"iso2c", "iso3c"), "_alloc")))
sect_alloc <- do.call("rbind", lapply(cty_alloc, '[', sect_idx,))
cty_place <- which(exio_ctys==cty)
# cty_idx_fd <- seq(7*(cty_place-1)+1, 7*cty_place)   # 7 final demand columns per country
# cty_idx <- seq(200*(cty_place-1)+1, 200*cty_place)  # 200 EXIO commodities per country
all_bp_idx <- c(map_idx, trd_idx, trp_idx)
own_ex_idx <- (cty_place-1)*200 + all_bp_idx
alloc <- apply(sect_alloc[,all_bp_idx], 2, mean)
indirec.int <- colSums(indirect_GHG_int[,own_ex_idx]) * EXR_EUR$r  # kg CO2eq/USD2007
direc.int <- colSums(emission_int[,own_ex_idx]) * EXR_EUR$r  # kg CO2eq/USD2007
comp <- rbind(as.integer(all_bp_idx), indirec.int, direc.int, alloc)
print(map_idx)
print(comp)  # MJ/Eur
return(comp)
}
a <- WDI(country = "FR", indicator = "NE.CON.PETC.KD", start = 2007, end = 2011, extra = FALSE, cache = NULL)
consumption_growth_FR <- a$NE.CON.PETC.KD[1]/a$NE.CON.PETC.KD[5]
FRA_FD_ICP_usd2007 <- as.matrix(fd_decile_FRA / CPI_ratio_FRA) / consumption_growth_FR # M.EUR to M.USD 2007 [length: 109]
GetTotalEmbeddedGHG <- function(country='IN') {
if(country=='ALL') {
cty_idx_fd <- 1:dim(final_demand)[2]
}
else {
cty_place <- which(exio_ctys==country)
cty_idx <- seq(200*(cty_place-1)+1, 200*cty_place)  # 200 EXIO commodities per country
cty_idx_fd <- seq(7*(cty_place-1)+1, 7*cty_place)   # 7 final demand columns per country
}
emb_GHG <- indirect_GHG_int %*% as.matrix(final_demand[,cty_idx_fd])
emb_GHG <- cbind(emb_GHG, rowSums(emb_GHG))
# country <- countrycode(country, "iso2c", "iso3c")
# pop2007 <- eval(parse(text=paste0(country, "_pop_2007")))
# return(colSums(emb_energy)/pop2007*1000)  # in GJ/capita
return(colSums(emb_GHG))  # in TJ
}
global_total <- 0
for (i in exio_ctys) {
country_total <- GetTotalEmbeddedGHG(i)[8]
global_total <- global_total + country_total
print(paste0(i, ' ', country_total))
}
BRA_emiss_inten_RAS_noVal <- SetupEmissionIntensities(final_alloc_list_BRA_noVal, NC_BRA_noVal, "BR")
BRA_emiss_inten_nonRAS_noVal <- SetupEmissionIntensities(alloc_nonRAS, NC_BRA_noVal, "BR")
SetupEmissionIntensities <- function (mapping_list, not_conv_idx , country = "IN") {
ind_intensity <- vector()
n_sector <- ifelse(country=="FR", n_sector_coicop, n_sector_icp_fuel)
null_demand_int <- matrix(0, 9600, n_sector)
SectoralE_per_hh <- vector()
cty_place <- which(exio_ctys==country)
cty_idx <- seq(200*(cty_place-1)+1, 200*cty_place)  # 200 EXIO commodities per country
cty_idx_fd <- seq(7*(cty_place-1)+1, 7*cty_place)   # 7 final demand columns per country
cty_fd <- matrix(final_demand[, cty_idx_fd[1]], nrow=200)  # The country's hh fd column to a matrix (200x48) in bp
a <- diag(1/rowSums(cty_fd))
a[is.infinite(a)] <- 0
cty_fd_ratio <- a %*% cty_fd  # fd exio-sectoral ratio in bp across countries
cty_fd_ratio <- matrix(cty_fd_ratio, ncol=1) # 9600x1
for (i in 1:length(mapping_list)) {  # length(mapping_list) instead of n_draws, because of potential no-convergence runs
draw_count <<- i  # Used in get_basic_price
# Identity mtx representing 1 2007USD spending in each ICP sector, now mapped to 200 EXIO sectors
unit_exio <- diag(n_sector) %*% mapping_list[[i]]  # 164x200
# To run without valuation, toggle comment on this line.
# fd_bp <- get_basic_price(t(unit_exio), country)  # Convert to bp (200x164) - each col represents bp fd in each exio sector (for 1 USD in ICP sector)
fd_bp <- t(unit_exio)
a <- do.call(rbind, replicate(48, fd_bp, simplify = FALSE))   # 48 regions in EXIO
fd_bp <- apply(a, 2, function(x) {x * cty_fd_ratio})  # 9600X164
# fd_exio <- mapping_list[[i]] %*% diag(fd_decile[,2])  # For Ensemble
# cty_fd <- null_demand_int
# cty_fd[cty_idx,] <- get_basic_price(fd_exio, country)
GHG_int <- indirect_GHG_int %*% fd_bp * EXR_EUR$r  # indirect energy use from the supply chains (MJ/USD2007)
# energy_tot <- indirect_E_int %*% cty_fd
ind_intensity <- rbind(ind_intensity, colSums(GHG_int)) # Total indirect energy/cap by decile
# print(colSums(energy_int)[75])
}
# not_conv_idx has 1 where the RAS did not converge.
ind_intensity <- ind_intensity[not_conv_idx!=1,]
return(ind_intensity)
}
BRA_emiss_inten_RAS_noVal <- SetupEmissionIntensities(final_alloc_list_BRA_noVal, NC_BRA_noVal, "BR")
BRA_emiss_inten_nonRAS_noVal <- SetupEmissionIntensities(alloc_nonRAS, NC_BRA_noVal, "BR")
View(BRA_emiss_inten_RAS_noVal)
View(BRA_inten_RAS_noVal)
BRA_GHG_inten_RAS_noVal <- SetupEmissionIntensities(final_alloc_list_BRA_noVal, NC_BRA_noVal, "BR")
BRA_GHG_inten_nonRAS_noVal <- SetupEmissionIntensities(alloc_nonRAS, NC_BRA_noVal, "BR")
str(BRA_emiss_inten_RAS_noVal)
str(emissions)
BRA_GHG_inten_RAS_combined_noVal <- BRA_GHG_inten_RAS_noVal
BRA_GHG_inten_RAS_combined_noVal[,no_expense_BRA] <- BRA_GHG_inten_RAS_combined_noVal[,no_expense_BRA] # emissions >>> CO2? non-CO2?
saveRDS(BRA_GHG_inten_RAS_combined_noVal, "C:/Users/tudeschi/Documents/DLE_scripts/Outputs/Saved tables/BRA_emiss_inten_RAS_combined_noVal.RDS")
saveRDS(BRA_GHG_inten_RAS_combined_noVal, "C:/Users/tudeschi/OneDrive - IIASA/Projects/ECOPA/ECOPA Final Task 3/Data/BRA_emiss_inten_RAS_combined_noVal.RDS")
saveRDS(BRA_GHG_inten_RAS_noVal, "C:/Users/tudeschi/OneDrive - IIASA/Projects/ECOPA/ECOPA Final Task 3/Data/BRA_emiss_inten_RAS_noVal.RDS")
View(CPI)
View(bridge_icp_exio)
ICP_catnames
write.csv(ICP_catnames, "C:/Users/tudeschi/OneDrive - IIASA/Projects/PhD/Outputs/Summary Tables/cpi_names.csv")
